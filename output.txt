
FILE: ./client/src/actions/user.actions.js

import axios from "axios";

export const GET_USER = "GET_USER";
export const UPLOAD_PICTURE = "UPLOAD_PICTURE";
export const UPDATE_BIO = "UPDATE_BIO"

export const getUser = (uid) => {
    return (dispatch) => {
        return axios
            .get(`${process.env.REACT_APP_API_URL}api/user/${uid}`)
            .then((res)=> {
                dispatch({type: GET_USER, payload: res.data});
            })
            .catch((err) => console.log(err));
    };
};

export const uploadPicture = (data, id) => {
    return  (dispatch) => {
        return axios
            .post(`${process.env.REACT_APP_API_URL}api/user/upload`,data)
            .then((res) => {
                return axios
                    .get(`${process.env.REACT_APP_API_URL}api/user/${id}`)
                    .then((res) =>{
                        dispatch({type: UPLOAD_PICTURE, payload: res.data.picture})
                    })
            })
            .catch((err) => console.log(err))
    };
};

export const updateBio = (userId, bio) =>{
    return (dispatch) => {
        return axios({
            method:"put",
            url: `${process.env.REACT_APP_API_URL}api/user/`+userId,
            data: {bio}
        })
        .then((res) =>{
            dispatch({type: UPDATE_BIO, payload: bio})
        })
        .catch((err) => console.log(err))
    }
}
FILE: ./client/src/actions/users.actions.js

import axios from "axios";

export const GET_USERS = "GET_USERS";

export const getUsers = () => {
    return (dispatch) => {
        return axios
        .get(`${process.env.REACT_APP_API_URL}api/user/`)
        .then((res) =>{
            dispatch({type: GET_USERS, payload: res.data});
        })
        .catch((err)=>console.log(err));
    }
}
FILE: ./client/src/App.js

import React, { useEffect, useState } from "react";
import Routes from "./Routes/routes";
import { UidContext } from "./Shared/AppContext";
import Axios from "axios";
import { useDispatch } from "react-redux";
import { getUser } from "./actions/user.actions";

const App = () => {
  const [uid, setUid] = useState(null);
  const dispatch = useDispatch();

  useEffect(() => {
    const fetchToken = async () => {
      try {
        const response = await Axios.get(`${process.env.REACT_APP_API_URL}jwtid`, {
          withCredentials: true,
        });
        setUid(response.data);
      } catch (err) {
        console.log("No.token");
      }
    };
    fetchToken();

    if(uid) dispatch(getUser(uid));
  }, [uid]);

  return(
    <UidContext.Provider value={uid}>
        <Routes />
    </UidContext.Provider>
  );
};

export default App;
FILE: ./client/src/components/Authentification/Login.js

import React, { useState } from "react";
import SignUpForm from "./SignUpForm";
import SignInForm from "./SignInForm";

const Log = (props) => {

   const [signUpModal, setSignUpModal]=useState(props.signup); 
   const [signInModal, setSignInModal]=useState(props.signin); 


   const handleModals= (e) => {
    if(e.target.id==="register") {
        setSignInModal(false);
        setSignUpModal(true);
    }  else if (e.target.id==="login"){
        setSignUpModal(false);
        setSignInModal(true);
    }
   }


  return(
    <div className="connection-form">
        <div className="form-container">
            <ul>
                <li onClick={handleModals} id="register" className={signUpModal? "active-btn" : null}>Sign up</li>
                <li onClick={handleModals} id="login" className={signInModal? "active-btn" : null}>Sign in</li>
            </ul>
            {signUpModal && <SignUpForm/>}
            {signInModal && <SignInForm/>}
        </div>
    </div>
  );
};

export default Log;
FILE: ./client/src/components/Authentification/Logout.js

import React from "react";
import axios from "axios";
import cookie from "js-cookie";

const Logout = () => {

    const removeCookie = (key) => {
        if (window !== "undefined") {cookie.remove(key, { expires: 1 });}
    };

    const logout = async () => {
        await axios({
            method: "get",
            url: `${process.env.REACT_APP_API_URL}api/user/logout`,
            withCredentials: true,
        })
            .then(() => removeCookie('jwt'))
            .catch((err) =>{
            console.log(err);
         })

            //window.location = "/";
    };

    return (
        <li onClick={logout}>
            <img src="./img/icons/logout.svg" alt="logout" />
        </li>
    );
};

export default Logout;
FILE: ./client/src/components/Authentification/SignInForm.js

import React, { useState } from "react";
import axios from "axios";

const SignInForm = () => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [errors, setErrors] = useState({});

  const handleLogin = (e) => {
    e.preventDefault();

    axios({
      method: "post",
      url: `${process.env.REACT_APP_API_URL}api/user/login`,
      withCredentials: true,
      data: {
        email,
        password,
      },
    })
      .then((res) => {
        console.log(res);
        if (res.data.errors) {
          setErrors(res.data.errors);
        } else {
          window.location = "/";
        }
      })
      .catch((err) => {
        console.log(err);
      });
  };

  return (
    <form action="" onSubmit={handleLogin} id="sign-up-form">
      <label htmlFor="email">Email</label>
      <br />
      <input
        type="text"
        name="email"
        id="email"
        onChange={(e) => setEmail(e.target.value)}
        value={email}
      />
      {errors.email && <div className="error">{errors.email}</div>}
      <br />

      <label htmlFor="password">Password</label>
      <br />
      <input
        type="password"
        name="password"
        id="password"
        onChange={(e) => setPassword(e.target.value)}
        value={password}
      />
      {errors.password && <div className="error">{errors.password}</div>}
      <br />

      <input type="submit" value="Login" />
    </form>
  );
};

export default SignInForm;
FILE: ./client/src/components/Authentification/SignUpForm.js

import React, { useState } from "react";
import axios from "axios";
import SignInForm from "./SignInForm";



const SignUpForm = () => {

  const [formSubmit, setFormSubmit] = useState('');
  const [pseudo, setPseudo] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [controlPassword, setControlPassword] = useState('');

  const handleRegister = async (e) => {
    e.preventDefault();
    const terms = document.getElementById('terms');
    const pseudoError = document.querySelector('.pseudo.error');
    const emailError = document.querySelector('.email.error');
    const passwordError = document.querySelector('.password.error');
    const passwordConfirmError = document.querySelector('.password-confirm.error');
    const termsError = document.querySelector('.terms.error');


    passwordConfirmError.innerHTML = "";
    termsError.innerHTML = "";

    if (password !== controlPassword || !terms.checked) {
      if (password !== controlPassword) passwordConfirmError.innerHTML = "Passwords don't match";

      if (!terms.checked) termsError.innerHTML = "Accept the general terms of use";
    } else {
      await axios({
        method: "post",
        url: `${process.env.REACT_APP_API_URL}api/user/register`,
        data: {
          pseudo,
          email,
          password
        }
      })
        .then((res) => {
          console.log(res);
          if (res.data.errors) {
            pseudoError.innerHTML = res.data.errors.pseudo;
            emailError.innerHTML = res.data.errors.email;
            passwordError.innerHTML = res.data.errors.password;
          } else {
            setFormSubmit(true);
          }
        })
        .catch((err) => console.log(err));
    }
  };

  return (
    <>
      {formSubmit ? (
        <>
          <SignInForm />
          <span></span>
          <h4 className="Sucess">Sign Up succeed, login</h4>
        </>

      ) : (


        <form action="" onSubmit={handleRegister} id="sign-up-form">

          <label htmlFor="pseudo">Pseudo</label>
          <br />
          <input type="text" name="pseudo" id="pseudo" onChange={(e) => setPseudo(e.target.value)} value={pseudo} />
          <div className="pseudo error"></div>
          <br />

          <label htmlFor="email">Email</label>
          <br />
          <input type="text" name="email" id="email" onChange={(e) => setEmail(e.target.value)} value={email} />
          <div className="email error"></div>
          <br />

          <label htmlFor="password">Password</label>
          <br />
          <input type="password" name="password" id="password" onChange={(e) => setPassword(e.target.value)} value={password} />
          <div className="password error"></div>
          <br />

          <label htmlFor="password-conf">Password Confirmation</label>
          <br />
          <input type="password" name="password" id="password-conf" onChange={(e) => setControlPassword(e.target.value)} value={controlPassword} />
          <div className="password-confirm error"></div>
          <br />

          <input type="checkbox" id="terms" />
          <label htmlFor="terms">I accept <a href="/" target="_blank" rel="noopener noreferrer">the general terms of use</a></label>
          .<div className="terms error"></div>

          <input type="submit" value="Validate" />

        </form>
      )}
    </>
  );
};

export default SignUpForm;
FILE: ./client/src/components/chat/chat.js

import React, { useState, useEffect, useRef } from 'react';
import { io } from 'socket.io-client';
import './chat.css';
const Chat = () => {   
    const [messages, setMessages] = useState([]);
    const [inputMessage, setInputMessage] = useState('');
    const socket = useRef(null);
    useEffect(() => {
        socket.current = io("http://localhost:3000");
        
        socket.current.on("connect", () => {
          console.log('WebSocket connected');
        });
    
        socket.current.on("message", (message) => {
          setMessages((prevMessages) => [...prevMessages, message]);
        });
    
        return () => {
          if (socket.current) {
            socket.current.disconnect();
          }
        };
      }, []);

      const sendMessage = () => {
        const newMessage = {
          id: "3000",
          message: inputMessage,
        };
      
        setMessages((prevMessages) => [...prevMessages, newMessage]);
        socket.current.emit("message",  {...newMessage} );
        setInputMessage('');
      };
      
      
      const renderMessage = (message, index) => {
        const isSentMessage = message.from === 'other';
      
        return (
          <div key={index} className={`media media-chat ${isSentMessage ? 'media-chat-reverse' : ''}`}>
            {!isSentMessage && (
              <img className="avatar" src="https://img.icons8.com/color/36/000000/administrator-male.png" />
            )}
            <div className="media-body">
              <p>{message.message}</p>
              
            </div>
          </div>
        );
      };
      
      
  return (

    <div className="chatbox">
            <div  class="messages">
                {messages.map((message, index) => renderMessage(message, index))}
            </div>

            <div className="publisher bt-1 border-light">
                <input type="text" placeholder="Write something"  value={inputMessage} onChange={(e) => setInputMessage(e.target.value)}/>
                <button id="sendMessage" type="button" onClick={sendMessage}>Send</button>
            </div>

    </div>
          
  );
};

export default Chat;

FILE: ./client/src/components/Events/Events.js

import React, { useState, useEffect } from "react";
import { GoogleMap, useJsApiLoader, Marker, InfoWindow } from "@react-google-maps/api";
import Menu from "@mui/material/Menu";
import MenuItem from "@mui/material/MenuItem";
import Modal from "@mui/material/Modal";
import Box from "@mui/material/Box";
import TextField from "@mui/material/TextField";
import Button from "@mui/material/Button";
import axios from "axios";
import "./Events.css";
import { useSelector } from "react-redux";


const Events = () => {
  const [latitude, setLatitude] = useState(0);
  const [longitude, setLongitude] = useState(0);
  const [markerPosition, setMarkerPosition] = useState(null); 
  const [actionMark, setActionMark] = useState(null);
  const [modalOpen, setModalOpen] = useState(false);
  const [eventsData, setEventsData] = useState([]); 
  const userData = useSelector((state) => state.userReducer); 
  const [selectedEvent, setSelectedEvent] = useState(null);

  const containerStyle = {
    width: "60vw",
    height: "60vh",
  };

  const createEvent = () => {
    const title = document.getElementById("title").value;
    const description = document.getElementById("description").value;
    const date = document.getElementById("date").value;
    let location = markerPosition ? [markerPosition.lat, markerPosition.lng] : [longitude, latitude];
    const eventData = { title, description, date, location, user: userData._id }; 
    axios
      .post("http://localhost:5000/api/events", eventData)
      .then((res) => {
        console.log(res.data);
        setModalOpen(false);
        setEventsData([...eventsData, res.data]);
      })
      .catch((err) => {
        console.log(err);
      });
  };
  const handleMarkerClick = (event) => {
    setActionMark(event.domEvent.currentTarget);
  };

  const openEventModal = () => {
    setActionMark(null);
    setModalOpen(true);
  };

  const handleMapClick = (event) => {
    setMarkerPosition({ lat: event.latLng.lat(), lng: event.latLng.lng() });
  };

  useEffect(() => {
    if (!navigator.geolocation) {
      window.alert("Geolocation is not supported by your browser");
    } else {
      navigator.geolocation.getCurrentPosition(success, error);
    }

    function success(position) {
      setLatitude(position.coords.latitude);
      setLongitude(position.coords.longitude);
    }

    function error() {
      window.alert("Unable to retrieve your location");
    }

    axios
      .get("http://localhost:5000/api/events")
      .then((res) => {
        setEventsData(res.data);
      })
      .catch((err) => {
        console.log(err);
      });
  }, []);

  const { isLoaded } = useJsApiLoader({
    id: "google-map-script",
    googleMapsApiKey: "AIzaSyDch5OcDgWH-sKCF5rDQq3yYJy8O0eyRuE",
  });

  const location = { lat: latitude, lng: longitude };

  return (
    <>
      <header className="googleMap">
        {isLoaded && (
          <GoogleMap
            mapContainerStyle={containerStyle}
            zoom={13}
            center={location}
            onClick={handleMapClick} 
          >
            {markerPosition && ( 
              <Marker
                key={1} 
                position={markerPosition}
                onClick={handleMarkerClick}
                icon="https://cdn.iconscout.com/icon/premium/png-256-thumb/pin-8243259-6574491.png?f=webp&w=56" 
              />
            )}
            {eventsData.map((event) => (
              <Marker
                key={event._id}
                position={{ lat: event.location[0], lng: event.location[1] }}
                icon="https://cdn.iconscout.com/icon/premium/png-256-thumb/pin-8253543-6589762.png?f=webp&w=56"
                onClick={() => setSelectedEvent(event)}  
            />
            
            ))}

            {selectedEvent && ( 
              <InfoWindow
                position={{ lat: selectedEvent.location[0], lng: selectedEvent.location[1] }}
                onCloseClick={() => setSelectedEvent(null)}
              >
                <div>
                  <h2>{selectedEvent.title}</h2>
                  <p>{selectedEvent.description}</p>
                  <p>{selectedEvent.date}</p>
                </div>
              </InfoWindow>
            )}

          </GoogleMap>
          
        )}
      </header>
      <Menu
        anchorEl={actionMark}
        open={Boolean(actionMark)}
        onClose={() => setActionMark(null)}
      >
        <MenuItem id="menuItem" onClick={openEventModal}>
          Create Event
        </MenuItem>
       
      </Menu>
      <Modal open={modalOpen} onClose={() => setModalOpen(false)}>
        <Box id="box">
          <TextField id="title" fullWidth label="Title" />
          <TextField id="description" fullWidth label="Description" />
          <TextField id="date" fullWidth type="datetime-local" />
          <Button fullWidth color="primary" onClick={createEvent}>
            Create
          </Button>
        </Box>
      </Modal>
    </>
  );
};

export default Events;
FILE: ./client/src/components/Home/home.js

const Home = () => {
    return (
        <>
    
        </>
    );
};

export default Home;

FILE: ./client/src/components/ParkingLots/GoogleMapsApi.js

import React from 'react'
import { GoogleMap, useJsApiLoader, Marker } from '@react-google-maps/api';
import ParkingSpotInfo from './ParkingSpotInfo';
import { Carousel } from 'react-responsive-carousel';
import './GoogleMapsApi.css';

const containerStyle = {
    width: '60vw',
    height: '60vh'
};


const MapComponent = (props) => {

    const coordinatesToObject = (coordinates) => {
        return {
          lat: coordinates[1],
          lng: coordinates[0],
        };
      };
      
    const { isLoaded } = useJsApiLoader({
        id: 'google-map-script',
        googleMapsApiKey: 'AIzaSyDch5OcDgWH-sKCF5rDQq3yYJy8O0eyRuE'
    })
    const location = {
        lat: props.latitude,
        lng: props.longitude
    };


    const parkingSpots = props.parkingLots;
 
    return isLoaded ? (
        <>

      <div class="googleMap">

              <GoogleMap
                  mapContainerStyle={containerStyle}
                  zoom={13}
                  center={location}
              >
              {parkingSpots && parkingSpots.records && parkingSpots.records.map((record, index) => (
          <Marker
            key={index}
            position={coordinatesToObject(record.geometry.coordinates)}
          />
        ))}
              </GoogleMap>

         </div>

    <div class="carousel">
          <Carousel
            showArrows
            swipeable
            useKeyboardArrows
            emulateTouch
          >
            {parkingSpots &&
              parkingSpots.records &&
              parkingSpots.records.map((record, index) => (
                <ParkingSpotInfo key={index} parkingSpot={record.fields} />
              ))}
          </Carousel>
    </div>
  </>
) : (
  <></>
);
}

export default MapComponent;  
FILE: ./client/src/components/ParkingLots/ParkingLots.js

import React, { useState, useEffect } from 'react';
import MapComponent from './GoogleMapsApi';
const LocateMe = () => {
  
  const [parkingLotsPoints, setParkingLotsPoints] = useState();
  const [latitude, setLatitude] = useState(0);
  const [longitude, setLongitude] = useState(0);

  useEffect(() => {

    let getParkingLotsPoints = async() => {
      
      const response = await fetch(`${process.env.REACT_APP_API_URL}api/parkingLots`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      }) 

      setParkingLotsPoints(await response.json());
  }

  getParkingLotsPoints();

  if (!navigator.geolocation) {
    window.alert('Geolocation is not supported by your browser');
  } else {
    navigator.geolocation.getCurrentPosition(success, error);
  }

  function success(position) {
    setLatitude(position.coords.latitude);
    setLongitude(position.coords.longitude);
  }

  function error() {
    window.alert('Unable to retrieve your location');
  }
  }, []);


  return (
    <div>
      <header >
      <MapComponent
          latitude={latitude}
          longitude={longitude}
          parkingLots={parkingLotsPoints}
        />
      </header>
    </div>
  );
};

export default LocateMe;

FILE: ./client/src/components/ParkingLots/ParkingSpotInfo.js

import React from 'react';
import 'react-responsive-carousel/lib/styles/carousel.min.css';

const ParkingSpotInfo = ({ parkingSpot }) => {
  return (
    <div className="parking-spot-info">
      <h3>{parkingSpot.nom}</h3>
      <p>{parkingSpot.adresse}</p>
      <p>Number of spots: {parkingSpot.nb_places}</p>
      <p>Price for 24 hours: {parkingSpot.tarif_24h} €</p>
      <p>Price PMR : {parkingSpot.tarif_pmr}</p>
      <p>Type of users: {parkingSpot.type_usagers}</p>
      <p>Info: {parkingSpot.info}</p>
    </div>
  );
};

export default ParkingSpotInfo;

FILE: ./client/src/components/Profil/FollowHandler.js


FILE: ./client/src/components/Profil/profil.js

import React, { useContext } from "react";
import Login from '../Authentification/Login';
import {UidContext} from "../../Shared/AppContext";
import UpdateProfil from "./UpdateProfil";

const Profil = () => {
  const uid = useContext(UidContext);
  return(
    <div className="profil-page">
      {uid? (
        <UpdateProfil />
      ): (
      <div className="log-container">
       <Login signin={false} signup={true} />
        <div className="img-container">
          <img src="./img/log.svg" alt = "img-log"/>
        </div>
      </div>
      )}
    </div>
  );
};

export default Profil;
FILE: ./client/src/components/Profil/UpdateProfil.js

import React, { useState } from "react";
import LeftNav from "../../Shared/leftNav";
import { useDispatch, useSelector } from "react-redux";
import UploadImg from "./UploadImg";
import { updateBio } from "../../actions/user.actions";
import { dateParser } from "../../Shared/utils";

const UpdateProfil = () => {
    const [bio, setBio] = useState('');
    const [updateForm, setUpdateForm] = useState(false);
    const userData = useSelector((state) => state.userReducer);
    const usersData = useSelector((state) => state.usersReducer);
    const dispatch = useDispatch();
    const [followingPopup, setFollowingPopup] = useState(false);
    const [followersPopup, setFollowersPopup] = useState(false);

    const handleUpdate = () => {
        dispatch(updateBio(userData._id, bio));
        setUpdateForm(false);
    }

    return (
        <div className="profil-container">
            <LeftNav />
            <h1> Profil de {userData.pseudo}</h1>
            <div className="update-container">
                <div className="left-part">
                    <h3>Photo de profil</h3>
                    <img src={userData.picture} alt="user-pic" />
                    <UploadImg />
                </div>
                <div className="right-part">
                    <div className="bio-update">
                        <h3>Bio</h3>
                        {updateForm === false && (
                            <>
                                <p onClick={() => setUpdateForm(!updateForm)}>{userData.bio}</p>
                                <button onClick={() => setUpdateForm(!updateForm)}>Modifier</button>
                            </>
                        )}
                        {updateForm && (
                            <>
                                <textarea type="text" defaultValue={userData.bio} onChange={(e) => setBio(e.target.value)}></textarea>
                                <button onClick={handleUpdate}> Validate modifications</button>
                            </>
                        )}
                    </div>
                    <br />
                    <h4>Member since: {dateParser(userData.createdAt)}</h4>
                    <h5 onClick={() => setFollowingPopup(true)}> Following: {userData.following ? userData.following.length : ""}</h5>
                    <h5 onClick={() => setFollowersPopup(true)}> followers: {userData.followers ? userData.followers.length : ""}</h5>
                </div>
            </div>
            {followingPopup && (
                <div className="popup-profil-container">
                    <div className="modal">
                        <h3>Following</h3>
                        <span className="cross" onClick={() => setFollowingPopup(false)}>&#10005;</span>
                        <ul>
                            {usersData.map((user) => {
                                for (let i = 0; i < userData.following.length; i++) {
                                    if (user._id === userData.following[i]) {
                                        return (
                                            <li key={user._id}>
                                                <img src={user.picture} alt="user-pic" />
                                                <h4>{user.pseudo}</h4>
                                                <h5>FOLLOW HANDLER</h5>
                                            </li>
                                        );
                                    }
                                }
                            })}
                        </ul>
                    </div>
                </div>
            )}


            {followersPopup && (
                <div className="popup-profil-container">
                    <div className="modal">
                        <h3>followers</h3>
                        <span className="cross" onClick={() => setFollowersPopup(false)}>&#10005;</span>
                        <ul>
                            {usersData.map((user) => {
                                for (let i = 0; i < userData.followers.length; i++) {
                                    if (user._id === userData.followers[i]) {
                                        return (
                                            <li key={user._id}>
                                                <img src={user.picture} alt="user-pic" />
                                                <h4>{user.pseudo}</h4>
                                                <h5>FOLLOW HANDLER</h5>
                                            </li>
                                        );
                                    }
                                }
                            })}
                        </ul>
                    </div>
                </div>
            )}

        </div>
    );
};

export default UpdateProfil;
FILE: ./client/src/components/Profil/UploadImg.js

import React, { useState } from "react";
import { useDispatch, useSelector } from "react-redux";
import { uploadPicture } from "../../actions/user.actions";

const UploadImg = () => {
    const [file, setFile] = useState();
    const dispatch = useDispatch();
    const userData = useSelector((state) => state.userReducer);

    const handlePicture = (e) => {
        e.preventDefault();
        const data = new FormData();
        data.append("name", userData.pseudo);
        data.append("userId", userData._id);
        data.append("file", file);

        dispatch(uploadPicture(data, userData._id));
    };

  return(
    <form action="" onSubmit={handlePicture} className="upload-pic">
        <label htmlFor="file">Change your profile Image</label>
        <input type="file" id="file" name="file" accept=".jpg, .jpeg .png"
        onChange={(e) => setFile(e.target.files[0])}/>
        <br/>
        <input type="submit" value="send" />
    </form>
  );
};

export default UploadImg;
FILE: ./client/src/index.js

import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './styles/index.scss';
import { Provider } from 'react-redux';
import { applyMiddleware, createStore } from 'redux';
import thunk from 'redux-thunk';
import rootReducer from './reducers/reducers';
import { getUsers } from './actions/users.actions';

//dev tools
import {composeWithDevTools} from 'redux-devtools-extension';

const store = createStore(
    rootReducer, composeWithDevTools(applyMiddleware(thunk))
)

store.dispatch(getUsers());

ReactDOM.render(
    <Provider store={store}>
        <App />,
    </Provider>,
    document.getElementById('root')
);



FILE: ./client/src/reducers/reducers.js

import { combineReducers } from "redux";
import userReducer from "./user.reducer";
import usersReducer from "./users.reducer";

export default combineReducers({
    userReducer,
    usersReducer,
})
FILE: ./client/src/reducers/user.reducer.js

import { GET_USER, UPDATE_BIO, UPLOAD_PICTURE } from "../actions/user.actions";

const initialState = {};

export default function userReducer(state= initialState, action){
    switch(action.type) {
        case GET_USER:
            return action.payload;
        case UPLOAD_PICTURE:    
            return {
                ... state,
                picture: action.payload
            }
        case UPDATE_BIO:
            return{
                ...state,
                bio: action.payload
            }
            
        default:
            return state;
    }
}
FILE: ./client/src/reducers/users.reducer.js

import { GET_USERS } from "../actions/users.actions";

const initialState ={};

export default function userReducer(state = initialState, action){
    switch (action.type) {
        case GET_USERS:
            return action.payload;
        default:
            return state;
    }
}


FILE: ./client/src/Routes/routes.js

import React from "react";
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import Navbar from '../Shared/Navbar';
import Home from "../components/Home/home"
import Chat from "../components/chat/chat";
import profil from "../components/Profil/profil"
import Events from "../components/Events/Events";
import LocateMe from "../components/ParkingLots/ParkingLots";

const Routes = () => {
  return (

    <Router>
      <Navbar/>
      <Switch>
        <Route path="/home" exact component={Home} />
        <Route path="/profil" exact component={profil} />
        <Route path="/chat" exact component={Chat} />
        <Route path="/parkings" exact component={LocateMe} />
        <Route path="/events" exact component={Events} />
      </Switch>
    </Router>

  );
};

export default Routes;
FILE: ./client/src/Shared/AppContext.js

import { createContext } from "react";

export const UidContext = createContext();
FILE: ./client/src/Shared/home.js

// home.js
import React from 'react';

const Home = () => {
    return (
        <h3>Home</h3>
    );
};

export default Home;

FILE: ./client/src/Shared/leftNav.js

import React from "react";
import { NavLink } from "react-router-dom";

const leftNav = () => {
  return(
    <div className="left-nav-container">
        <div className="icons">
            <div className="icons-bis">
                <NavLink to='/' exact activeClassName="active-left-nav">
                    <img src="./img/icons/home.svg" alt="home"/>
                </NavLink>
                <br/>
                <NavLink to='/trending' exact activeClassName="active-left-nav">
                    <img src="./img/icons/rocket.svg" alt="home"/>
                </NavLink>
                <br/>
                <NavLink to='/profil' exact activeClassName="active-left-nav">
                    <img src="./img/icons/user.svg" alt="home"/>
                </NavLink>
            </div>
        </div>
    </div>
  );
};

export default leftNav;
FILE: ./client/src/Shared/Navbar.js

import React, { useContext } from "react";
import { NavLink } from "react-router-dom";
import { UidContext } from "./AppContext";
import Logout from "../components/Authentification/Logout";
import { useSelector } from "react-redux";

const Navbar = () => {
    const uid = useContext(UidContext);
    const userData = useSelector((state)=> state.userReducer);

    return (
        <nav>
            <div className="nav-container">
                <div className="logo">
                    <NavLink exact to="/">
                        <div className="logo">
                            <img src="./img/handimap.jpg" alt="icon" />
                            <h3>handiMap</h3>
                        </div>
                    </NavLink>
                </div>
                {uid ? (
                    <ul>
                        <li></li>
                        <li className="welcome">
                            <NavLink exact to="/profil">
                                <h5>Welcome {userData.pseudo}</h5>
                            </NavLink>
                        </li>
                        <Logout />
                    </ul>
                ) : (
                    <ul>
                        <li></li>
                        <li>
                            <NavLink exact to="/profil">
                            <img src="./img/icons/login.svg" alt="login" />
                            </NavLink>
                        </li>
                    </ul>
                )}
            </div>
        </nav>

    );
};

export default Navbar;
FILE: ./client/src/Shared/utils.js

export const dateParser = (num) => {
    let options = {hour: "2-digit", minute: "2-digit", second: "2-digit", weekday: "long", year: "numeric", 
        month: "short", day:"numeric"};
    
    let timestamp = Date.parse(num);

    let date = new Date(timestamp).toLocaleDateString('En-EN', options);

    return date.toString();

}
FILE: ./config/db.js

const mongoose = require("mongoose");

mongoose
    .connect(
        "mongodb+srv://" + process.env.DB_USER_PASS + "@clustersocialmedia.iw1qlya.mongodb.net/socialMedia",
        {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        }
    )
    .then(()=> console.log("Connected to MongodB"))
    .catch((err)=> console.log("Failed to connect to MongodB", err));


FILE: ./controllers/auth.controller.js

const UserModel = require('../models/user.model');
const jwt = require('jsonwebtoken');
const { signUpErrors, signInErrors } = require('../utils/errors.utils');

const maxAge = 3*24*60*1000;
const createToken = (id)=> {
    return jwt.sign({id}, process.env.TOKEN_SECRET,{
        expiresIn: maxAge
    })
};


module.exports.signUp = async (req, res) =>{
    console.log(req.body);
    const {pseudo, email, password} = req.body

    try {
        const user = await UserModel.create({pseudo, email, password});
        res.status(201).json({user: user._id});
    }
    catch(err) {
        const errors= signUpErrors(err);
        res.status(200).send({errors})
    }
}

module.exports.signIn = async(req,res)=> {
    const {email, password} = req.body

    try{
        const user = await UserModel.login(email, password);
        const token = createToken(user._id);
        res.cookie('jwt', token, {httpOnly: true, maxAge});
        res.status(200).json({user: user._id})
    } 
    catch(err){
        const errors = signInErrors(err);
        res.status(200).json({errors});
    }
}

module.exports.logout = function(req, res) {
    res.cookie('jwt', '', {maxAge: 1});
    res.redirect('/');
  };
FILE: ./controllers/event.controller.js

const EventModel = require("../models/event.model");

exports.insertEvent = async (req, res) => {
  try {
    const { title, description, date, location, user } = req.body;
    const event = new EventModel({ title, description, date, location, user });
    await event.save();
    res.status(201).json(event);
  } catch (err) {
    console.log(err); 
    res.status(500).json({ message: err.message });
  }
};


exports.getEvents = async (req, res) => {
  try {
    const events = await EventModel.find();
    res.status(200).json(events);
  } catch (err) {
    console.log(err);
    res.status(500).json({ message: err.message });
  }
};

FILE: ./controllers/post.controller.js

const postModel = require('../models/post.model');
const PostModel = require('../models/post.model');
const UserModel = require('../models/user.model');
const { uploadErrors } = require('../utils/errors.utils');
const ObjectID = require('mongoose').Types.ObjectId;
const fs = require('fs');
const { promisify } = require('util');

module.exports.readPost = async (req, res) => {
    try {
        const posts = await PostModel.find().sort({ createdAt: -1 });
        res.send(posts);
    } catch (err) {
        console.log(err);
        res.status(500).send('Internal Server Error');
    }
};

module.exports.createPost = async (req, res) => {

    let fileName;

    if (req.file !== null) {
        try {
            if (!/\.(jpg|jpeg|png)$/i.test(req.file.originalname)) {
                throw Error("invalid file");
            }

            if (req.file.size > 500000) throw Error("max size")
        } catch (err) {
            const errors = uploadErrors(err);
            return res.status(500).send({ errors });
        }

        console.log('req.file', req.file);
        // Get the file object from the request
        const file = req.file;
        fileName = req.body.posterId + Date.now() + '.jpg';

        // Create a write stream to save the file to the file system
        const stream = fs.createWriteStream(`${__dirname}/../client/public/uploads/posts/${fileName}`);
        const imageData = req.file.buffer;

        stream.write(imageData);
    }


    const newPost = new postModel({
        posterId: req.body.posterId,
        message: req.body.message,
        picture: req.file !== null ? "./uploads/posts/" + fileName : "",
        video: req.body.video,
        likers: [],
        comments: [],
    });

    try {
        const post = await newPost.save();
        return res.status(201).json(post);
    } catch (err) {
        return res.status(400).send(err);
    }
};

module.exports.updatePost = async (req, res) => {
    if (!ObjectID.isValid(req.params.id)) {
        return res.status(400).send("ID unknown: " + req.params.id);
    }

    const updatedRecord = {
        message: req.body.message,
    };

    try {
        const updatedPost = await PostModel.findByIdAndUpdate(
            req.params.id,
            { $set: updatedRecord },
            { new: true }
        );
        res.send(updatedPost);
    } catch (err) {
        console.log("Update error: " + err);
        res.status(500).send("Internal server error");
    }
};

module.exports.deletePost = async (req, res) => {
    if (!ObjectID.isValid(req.params.id)) {
        return res.status(400).send("ID unknown: " + req.params.id);
    }

    try {
        const deletedPost = await PostModel.findByIdAndRemove(req.params.id);
        res.send(deletedPost);
    } catch (err) {
        console.log("Delete error: " + err);
        res.status(500).send("Internal server error");
    }
};

module.exports.likePost = async (req, res) => {
    try {
        const postId = req.params.id;
        const userId = req.body.id;

        if (!ObjectID.isValid(postId)) {
            return res.status(400).send("Unknown ID: " + postId);
        }

        const post = await PostModel.findByIdAndUpdate(
            postId,
            {
                $addToSet: { likers: userId },
            },
            { new: true }
        );
        if (!post) {
            return res.status(404).send("Post not found with ID: " + postId);
        }

        const user = await UserModel.findByIdAndUpdate(
            userId,
            {
                $addToSet: { likes: postId },
            },
            { new: true }
        );
        if (!user) {
            return res.status(404).send("User not found with ID: " + userId);
        }

        res.send({ post, user });
    } catch (err) {
        console.error(err);
        return res.status(500).send("Internal server error");
    }
};

module.exports.unlikePost = async (req, res) => {
    try {
        const postId = req.params.id;
        const userId = req.body.id;

        if (!ObjectID.isValid(postId)) {
            return res.status(400).send("Unknown ID: " + postId);
        }

        const post = await PostModel.findByIdAndUpdate(
            postId,
            {
                $pull: { likers: userId },
            },
            { new: true }
        );
        if (!post) {
            return res.status(404).send("Post not found with ID: " + postId);
        }

        const user = await UserModel.findByIdAndUpdate(
            userId,
            {
                $pull: { likes: postId },
            },
            { new: true }
        );
        if (!user) {
            return res.status(404).send("User not found with ID: " + userId);
        }

        res.send({ post, user });
    } catch (err) {
        console.error(err);
        return res.status(500).send("Internal server error");
    }

}

module.exports.commentPost = async (req, res) => {
    try {
        const postId = req.params.id;

        if (!ObjectID.isValid(postId)) {
            return res.status(400).send("Invalid post ID: " + postId);
        }

        const comment = {
            commenterId: req.body.commenterId,
            commenterPseudo: req.body.commenterPseudo,
            text: req.body.text,
            timestamp: new Date().getTime(),
        };

        const post = await PostModel.findByIdAndUpdate(
            postId,
            {
                $push: { comments: comment },
            },
            { new: true }
        );
        if (!post) {
            return res.status(404).send("Post not found with ID: " + postId);
        }

        res.send(post);
    } catch (err) {
        console.error(err);
        return res.status(500).send("Internal server error");
    }
};

module.exports.editCommentPost = async (req, res) => {
    try {
        const postId = req.params.id;
        const commentId = req.body.commentId;
        const newText = req.body.text;

        if (!ObjectID.isValid(postId)) {
            return res.status(400).send("Invalid post ID: " + postId);
        }

        const post = await PostModel.findById(postId);
        if (!post) {
            return res.status(404).send("Post not found with ID: " + postId);
        }

        const comment = post.comments.id(commentId);
        if (!comment) {
            return res.status(404).send("Comment not found with ID: " + commentId);
        }

        comment.text = newText;
        await post.save();

        res.status(200).send(post);
    } catch (err) {
        console.error(err);
        res.status(500).send("Internal Server Error");
    }
};

module.exports.deleteCommentPost = async (req, res) => {
    if (!ObjectID.isValid(req.params.id)) {
        return res.status(400).send("ID unknown: " + req.params.id);
    }

    try {
        const docs = await PostModel.findByIdAndUpdate(
            req.params.id,
            {
                $pull: {
                    comments: {
                        _id: req.body.commentId,
                    },
                },
            },
            { new: true }
        ).exec();

        if (!docs) return res.status(404).send('Comment not found');

        return res.send(docs);
    } catch (err) {
        return res.status(400).send(err);
    }
}

FILE: ./controllers/upload.controller.js

const UserModel = require('../models/user.model');
const fs = require('fs');
const { promisify } = require('util');
const { uploadErrors } = require('../utils/errors.utils');
const pipeline = promisify(require('stream').pipeline);
const { Readable } = require('stream');



module.exports.uploadProfil = async (req, res, next) => {

  try {
    if (!/\.(jpg|jpeg|png)$/i.test(req.file.originalname)) {
      throw Error("invalid file");
    }

    if(req.file.size >500000) throw Error("max size")
    } catch (err) {
    const errors = uploadErrors(err);
    return res.status(500).send({errors});
} 
 
  console.log('req.file', req.file);
  // Get the file object from the request
  const file = req.file;
 const fileName= req.body.name + ".jpg";
  // Create a write stream to save the file to the file system
  const stream = fs.createWriteStream(`${__dirname}/../client/public/uploads/profil/${fileName}`);
  const imageData = req.file.buffer;
  
  stream.write(imageData);
/*
  stream.on('open', () => {
    const readStream = new Readable();
    readStream.push(imageData);
    readStream.push(null);
    readStream.on('data', chunk => {
    stream.write(chunk);
    });
    readStream.on('end', () => {
    stream.end();
    });
  });
*/

try {
  const updatedUser = await UserModel.findByIdAndUpdate(
    req.body.userId,
    { $set : {picture: "./uploads/profil/"+fileName}},
    {new: true, upsert: true, setDefaultsOnInsert: true}
  ).exec();

  return res.send(updatedUser);
} catch (err) {
  return res.status(500).send({ message: err.message });
}
};
FILE: ./controllers/user.controller.js

const UserModel = require('../models/user.model');
const ObjectID = require('mongoose').Types.ObjectId;

module.exports.getAllUsers = async(req, res)=> {
    const users = await UserModel.find().select('-password');
    res.status(200).json(users);
}

module.exports.userInfo = (req, res)=> {
    if(!ObjectID.isValid(req.params.id))
        return res.status(400).send('ID unknown: ' + req.params.id)

    UserModel.findById(req.params.id)
        .select('-password')
        .then(docs => {
            res.send(docs);
          })
        .catch(err=>{
            console.log('ID unknown: ' + err);
        });
};

module.exports.updateUser = async (req, res) => {
    if (!ObjectID.isValid(req.params.id)) {
      return res.status(400).send('ID unknown: ' + req.params.id);
    }
  
    try {
      const updatedUser = await UserModel.findOneAndUpdate(
        { _id: req.params.id },
        {
          $set: {
            bio: req.body.bio,
          },
        },
        { new: true, upsert: true, setDefaultsOnInsert: true }
      );
      return res.send(updatedUser);
    } catch (error) {
      console.error(error);
      return res.status(500).json({ message: error.message });
    }
};

module.exports.deleteUser= async (req,res)=> {
    if (!ObjectID.isValid(req.params.id)) {
        return res.status(400).send('ID unknown: ' + req.params.id);
    }

    try{
        await UserModel.deleteOne({_id: req.params.id}).exec();
        res.status(200).json({message: "Successfully deleted. "});
    } catch(err) {
        return res.status(500).json({message: err});
    }
};

module.exports.follow = async (req, res) => {
    if (!ObjectID.isValid(req.params.id) || !ObjectID.isValid(req.body.idToFollow)) {
      return res.status(400).send('ID unknown: ' + req.params.id);
    }
  
    try {
      // add to the follower list
      const user = await UserModel.findByIdAndUpdate(
        req.params.id,
        { $addToSet: { following: req.body.idToFollow } },
        { new: true, upsert: true }
      ).exec();
      
      
      // add to the following list
      const userToFollow = await UserModel.findByIdAndUpdate(
        req.body.idToFollow,
        { $addToSet: { followers: req.params.id } },
        { new: true, upsert: true }
      ).exec();
  
      res.status(201).json({ user, userToFollow });
    } catch (err) {
      return res.status(500).json({ message: err.message });
    }
  };

  module.exports.unfollow = async (req, res) => {
    if (!ObjectID.isValid(req.params.id) || !ObjectID.isValid(req.body.idToUnFollow)) {
      return res.status(400).send('ID unknown: ' + req.params.id);
    }
  
    try {
      
      const user = await UserModel.findByIdAndUpdate(
        req.params.id,
        { $pull: { following: req.body.idToUnFollow } },
        { new: true, upsert: true }
      ).exec();
      
      
      // add to the following list
      const userToFollow = await UserModel.findByIdAndUpdate(
        req.body.idToUnFollow,
        { $pull: { followers: req.params.id } },
        { new: true, upsert: true }
      ).exec();
  
      res.status(201).json({ user, userToFollow });
    } catch (err) {
      return res.status(500).json({ message: err.message });
    }
};
FILE: ./index.js

const express = require('express');
const app = express();
const bodyParser = require('body-parser');
const cookieParser = require('cookie-parser');
const userRoutes = require('./routes/user.routes');
const postRoutes = require('./routes/post.routes');
const eventRoutes = require("./routes/event.route");
const directionsRoutes = require('./routes/directions.routes');
const parkingLotsRoutes = require('./routes/parkingLots.routes');

require('dotenv').config({path: './config/.env'});
require('./config/db');
const {checkUser, requireAuth} = require('./middleware/auth.middleware');

const cors = require('cors');
const http = require('http').createServer(app);
const io = require('socket.io')(http);

const corsOptions = {
  origin: true,
  credentials: true,
  allowedHeaders: ['sessionId', 'Content-Type'],
  exposedHeaders: ['sessionId'],
  methods: 'GET, HEAD, PUT, PATCH, POST, DELETE',
  preflightContinue: false,
};

app.use(cors(corsOptions));

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({extended: true}));
app.use(cookieParser());

//routes
app.use('/api/user', userRoutes);
app.use('/api/post', postRoutes);
app.use('/api/directions', directionsRoutes); 
app.use('/api/parkingLots', parkingLotsRoutes); 
app.use("/api/events", eventRoutes);

app.get('*', checkUser);
app.get('/jwtid', requireAuth, (req, res)=> {
    res.status(200).send(res.locals.user._id)
});

// server
app.listen(5000, () => {
    console.log(`Listening on port 5000`)
});

const connected_clients = new Set();
io.on('connect', (socket) => {
    connected_clients.add(socket.id);
    socket.on('disconnect', () => {
      connected_clients.delete(socket.id);
    });
    socket.on('message', (message) => {
        for (let client of connected_clients) {
        if (client !== socket.id) {
            message.from = 'other';
            io.to(client).emit('message', message);
        }
    }
  });
});

http.listen(5001, () => {
    console.log('websocket listening on port 5001');
});

FILE: ./middleware/auth.middleware.js

const jwt = require('jsonwebtoken');
const UserModel = require('../models/user.model');

module.exports.checkUser = (req, res, next)=> {
    const token = req.cookies.jwt;
    if(token){
        jwt.verify(token, process.env.TOKEN_SECRET, async(err, decodedToken) => {
           if(err) {
            res.locals.user = null;
            //res.cookie("jwt", "", { maxAge: 1});
            next();
           } else {
            let user = await UserModel.findById(decodedToken.id);
            res.locals.user = user;
            console.log(res.locals.user);
            next();
           }
        });
    } else {
        res.locals.user = null;
        next();
    }
}

module.exports.requireAuth = (req, res, next)=> {
    const token = req.cookies.jwt;
    if(token){
        jwt.verify(token, process.env.TOKEN_SECRET, async(err, decodedToken) => {
           if(err) {
                console.log(err);
            } else {
                console.log(decodedToken.id);
                next();
           }
        });
    } else {
        console.log('No token');
    }
};
FILE: ./models/event.model.js

const mongoose = require("mongoose");

const eventSchema = new mongoose.Schema({
  title: { type: String, required: true }, 
  description: { type: String, required: true }, 
  date: { type: Date, required: true }, 
  location: { type: [Number], required: true }, 
  user: { type: mongoose.Schema.Types.ObjectId, ref: "user", required: true }, 
});

module.exports = mongoose.model("event", eventSchema);
FILE: ./models/post.model.js

const mongoose = require('mongoose');

const PostSchema = new mongoose.Schema(
    {
        posterId: {
            type: String,
            required: true
        },
        message: {
            type: String,
            trim: true,
            maxlength:500,
        },
        picture: {
            type: String,
        },
        video: {
            type: String,
        },
        likers: {
            type: [String],
            required: true,
        },

        comments: {
            type: [
                {
                    commenterId: String,
                    commenterPseudo: String,
                    text: String,
                    timestamp: Number,  
                }
            ],
            required: true,
        },
    },
    {
        timestamps: true,
    }
);

module.exports = mongoose.model('post', PostSchema)
FILE: ./models/user.model.js

const mongoose = require('mongoose');
const{isEmail} = require('validator');
const bcrypt = require('bcrypt');

const userSchema = new mongoose.Schema(
    {
        pseudo: {
            type: String,
            required: true,
            minlength: 3,
            maxlength: 55,
            unique: true,
            trim: true
        },
        email: {
            type: String,
            required: true,
            validate: [isEmail],
            lowercase: true,
            unique: true,
            trim: true 
        },
        password: {
            type: String,
            required: true,
            max: 1024,
            minlength: 6
        },
        picture: {
           type: String,
           default: "./uploads/profil/random-user.png" 
        },
        bio: {
            type: String,
            max: 1024,
        },
        followers: {
            type: [String]
        },
        following: {
            type: [String]
        },
        likes: {
            type: [String]
        }
    },
    {
        timestamps: true,
    }
);

// play function before save into display: 'block'
userSchema.pre("save", async function(next) {
    const salt = await bcrypt.genSalt();
    this.password = await bcrypt.hash(this.password, salt);
    next();
});

userSchema.statics.login = async function(email, password) {
    const user = await this.findOne({ email });
    if(user) {
      const auth = await bcrypt.compare(password, user.password);
      if(auth){
        return user;
      }
      throw new Error('Incorrect Password');
    }
    throw new Error('Unknown Email');
};

const UserModel = mongoose.model("user",userSchema);

module.exports = UserModel;
FILE: ./routes/directions.routes.js

const express = require('express');
const router = express.Router();
const fetch = require('node-fetch');

router.get('/:mode', async (req, res) => {
    try {
      const mode = req.params.mode;
      const baseUrl = 'https://api.mapbox.com/directions/v5/mapbox/';
      const params = 'cycling';
      const coordinates = '-84.518641,39.134270;-84.512023,39.102779?geometries=';
      const geometries = 'geojson';
      const accessToken = 'pk.eyJ1Ijoib21heW9zIiwiYSI6ImNsZWZ1OWduMTAwZzkzeXBwM3JuOGt3NHYifQ.S-lEPoSClHUW39vDNBaQgA';
      const response = await fetch(baseUrl + mode + '/' + coordinates + geometries + '&access_token=' + accessToken);
      if (response.status === 200) {
        const data = await response.json();
        res.json(data);
      }
    } catch (err) {
      res.status(500).send({ message: err.message });
    }
  });

  module.exports = router;

FILE: ./routes/event.route.js

const express = require("express");
const router = express.Router();

const controller = require("../controllers/event.controller");

router.post("/", controller.insertEvent);
router.get("/", controller.getEvents);

module.exports = router;

FILE: ./routes/parkingLots.routes.js

const express = require('express');
const router = express.Router();
const fetch = require('node-fetch');

router.get('/', async (req, res) => {
  try {
    const url = "https://opendata.paris.fr/api/records/1.0/search/?dataset=stationnement-en-ouvrage&q=&rows=1000&refine.gratuit=0&refine.tarif_pmr=tarif_special";
    const response = await fetch(url);
    if (response.status === 200) {
      const data = await response.json();
      res.json(data);
    }
  } catch (err) {
    res.status(500).send({ message: err.message });
  }
});

module.exports = router;
FILE: ./routes/post.routes.js

const router = require('express').Router();
const postController = require('../controllers/post.controller');

const multer = require('multer');
const upload = multer();

router.get('/', postController.readPost);
router.post('/', upload.single('file'),postController.createPost);
router.put('/:id', postController.updatePost);
router.delete('/:id', postController.deletePost);
router.patch('/like-post/:id', postController.likePost);
router.patch('/unlike-post/:id', postController.unlikePost);

//comments
router.patch('/comment-post/:id', postController.commentPost);
router.patch('/edit-comment-post/:id', postController.editCommentPost);
router.patch('/delete-comment-post/:id', postController.deleteCommentPost);


module.exports = router;
FILE: ./routes/user.routes.js

const router = require('express').Router();
const authController = require('../controllers/auth.controller');
const userController = require('../controllers/user.controller');
const uploadController = require('../controllers/upload.controller');
const multer = require('multer');
const upload = multer();




//auth
router.post("/register", authController.signUp);
router.post('/login', authController.signIn);
router.post('/logout', authController.logout);




//user display: 'block',
router.get('/', userController.getAllUsers);
router.get('/:id', userController.userInfo);
router.put("/:id", userController.updateUser);
router.delete('/:id', userController.deleteUser);
router.patch('/follow/:id', userController.follow);
router.patch('/unfollow/:id', userController.unfollow);


//upload

router.post('/upload', upload.single('file'), uploadController.uploadProfil)





module.exports = router;
FILE: ./utils/errors.utils.js

module.exports.signUpErrors = (err)=>{
    let errors = {pseudo: "", email: "", password: ""};

    if(err.message.includes("pseudo")) errors.pseudo = "Incorrect pseudo or already taken";
    
    if(err.message.includes("email")) errors.email= "Incorrect email";  
    
    if(err.message.includes("password")) errors.password = " 6 minimum characters";
    
    if(err.code===11000 && Object.keys(err.keyValue)[0].includes("pseudo"))
        errors.pseudo = "This pseudo is already taken";

    if(err.code===11000 && Object.keys(err.keyValue)[0].includes("email"))
        errors.email = "This email is registered";
    
    return errors;
};

module.exports.signInErrors = (err) => {
  let errors = { email: '', password: '' };
  
    if (err.message.includes("Email") && err.message.includes("Unknown")) {
      errors.email = "Unknown Email";
    }
  
    if (err.message.includes("Password") && err.message.includes("Incorrect")) {
      errors.password = "Incorrect Password";
    }
  
  return errors;
};


module.exports.uploadErrors = (err) => {
  let errors = { format: '', maxSize:""};

  if(err.message.includes('invalid file')){
    errors.format = "incompatible format";
  }

  if(err.message.includes('max size')){
    errors.maxSize = "Max size : 500ko ";
  }

  return errors
}